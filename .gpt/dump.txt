<./.env>
# ===== App =====
SECRET_KEY=change-me
OPENAI_API_KEY=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
# ===== Stripe (dummy) =====
STRIPE_SECRET_KEY=sk_test_dummy
STRIPE_WEBHOOK_SECRET=whsec_dummy
# ===== Whisper =====
WHISPER_MODEL_SIZE=base



<./.gitignore>
####################
................................

<./docker-compose.yml>
version: "3.8"
services:
  backend:
    build: ./backend
    ports:
      - "4131:8000"
    volumes:
      - ./data:/app/data         # audio + sqlite
    env_file:
      - .env

  frontend:
    build: ./frontend
    ports:
      - "4132:80"
    depends_on:
      - backend



<./backend\Dockerfile>
FROM python:3.12-sli
................................

<./backend\requirements.txt>
fastapi==0.111.0
uvicorn[standard]==0.29.0

sqlmodel==0.0.16
pydantic-settings==2.3.1
python-multipart==0.0.9

# speech-to-text
faster-whisper==1.1.1

# OpenAI & deps
openai==1.23.6               # 1.23 is the newest that still ships the v1 SDK
httpx<0.27                   # keep httpx â‰¤ 0.26 so openaiâ€™s legacy `proxies=` arg works


<./backend\app\config.py>
from pathlib import Path
from functools import lru_cache
from pydantic_settings import BaseSettings, SettingsConfigDict

BASE_DIR = Path(__file__).resolve().parent.parent

class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_file=".env", extra="ignore")

    secret_key: str
    openai_api_key: str
    whisper_model_size: str = "tiny"

    db_path: Path = BASE_DIR / "data" / "db.sqlite3"

@lru_cache
def get_settings() -> "Settings":
    return Settings()

settings = get_settings()



<./backend\app\main.py>
"""
FastAPI backend for MeetScribe MVP.
Handles meeting creation, chunk uploads, transcription and summarisation.
"""

from __future__ import annotations

import logging
import shutil
import uuid
from pathlib import Path
from typing import List

import av
import openai
from fastapi import FastAPI, File, Form, HTTPException, UploadFile
from fastapi.responses import JSONResponse
from sqlmodel import Session, SQLModel, create_engine

from .config import settings
from .models import Meeting, MeetingCreate, MeetingRead

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
LOGGER = logging.getLogger("meetscribe")
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(levelname)s [%(name)s] %(message)s",
)

openai.api_key = settings.openai_api_key

engine = create_engine(f"sqlite:///{settings.db_path}", echo=False)
SQLModel.metadata.create_all(engine)

AUDIO_DIR = Path("data/audio")
AUDIO_DIR.mkdir(parents=True, exist_ok=True)

from faster_whisper import WhisperModel  # noqa: E402

_whisper = WhisperModel(
    settings.whisper_model_size,
    device="cpu",
    compute_type="int8",
)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def transcribe(path: Path) -> str:
    segments, _ = _whisper.transcribe(str(path), beam_size=5)
    return " ".join(s.text for s in segments)


def summarise(text: str) -> str:
    rsp = openai.chat.completions.create(
        model="gpt-4.1-mini-2025-04-14",
        temperature=0.3,
        messages=[
            {"role": "system", "content": "You summarise meetings into markdown."},
            {"role": "user", "content": f"Summarise:\n{text}"},
        ],
    )
    return rsp.choices[0].message.content.strip()


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ FastAPI application â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app = FastAPI(title="MeetScribe MVP")


@app.post("/api/meetings", response_model=MeetingRead, status_code=201)
def create_meeting(body: MeetingCreate):
    with Session(engine) as db:
        mtg = Meeting(**body.dict())
        db.add(mtg)
        db.commit()
        db.refresh(mtg)
        LOGGER.info("ğŸ†•  meeting %s created (expected_chunks=%s)", mtg.id, mtg.expected_chunks)
        return mtg


@app.post("/api/chunks")
async def upload_chunk(
    meeting_id: uuid.UUID = Form(...),
    chunk_id: str = Form(...),
    file: UploadFile = File(...),
):
    with Session(engine) as db:
        mtg = db.get(Meeting, meeting_id)
        if not mtg:
            raise HTTPException(404, "meeting not found")

        if mtg.done:
            LOGGER.info("â©  meeting %s already done â€“ chunk %s ignored", meeting_id, chunk_id)
            return {"ok": True, "ignored": True}

        # save file
        mtg_dir = AUDIO_DIR / str(meeting_id)
        mtg_dir.mkdir(parents=True, exist_ok=True)
        chunk_path = mtg_dir / f"{chunk_id}.webm"
        with chunk_path.open("wb") as f:
            shutil.copyfileobj(file.file, f)

        size_kb = chunk_path.stat().st_size / 1024
        LOGGER.info("â¬†ï¸  chunk %s for %s (%.1f kB)", chunk_id, meeting_id, size_kb)

        if size_kb < 4:
            LOGGER.warning("âš ï¸  chunk %s too small â€“ skipped", chunk_id)
            return {"ok": True, "skipped": True}

        try:
            text = transcribe(chunk_path)
        except av.error.InvalidDataError:
            LOGGER.exception("âš ï¸  chunk %s could not be decoded â€“ skipped", chunk_id)
            return {"ok": True, "skipped": True}

        LOGGER.info("ğŸ“  transcribed %.1f kB â†’ %d chars", size_kb, len(text))
        LOGGER.info("   %s", text[:120] + ("â€¦" if len(text) > 120 else ""))
        mtg.transcript_text = (mtg.transcript_text or "") + " " + text
        mtg.received_chunks += 1

        if (
            mtg.summary_markdown is None
            and (mtg.expected_chunks is None or mtg.received_chunks >= mtg.expected_chunks)
        ):
            mtg.summary_markdown = summarise(mtg.transcript_text)
            mtg.done = True
            LOGGER.info("âœ…  meeting %s summarised", meeting_id)

        db.add(mtg)
        db.commit()
        return {"ok": True}


@app.get("/api/meetings/{mid}", response_model=MeetingRead)
def get_meeting(mid: uuid.UUID):
    with Session(engine) as db:
        mtg = db.get(Meeting, mid)
        if not mtg:
            raise HTTPException(404)
        return mtg


@app.get("/healthz")
def health() -> dict[str, str]:
    return {"status": "ok"}


<./backend\app\models.py>
import uuid
import datetime as dt
from typing import Optional

from sqlmodel import SQLModel, Field

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Data-models
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


class Meeting(SQLModel, table=True):
    """
    Main DB table for a recorded meeting.

    â€¢ `id`               â€“ primary-key UUID
    â€¢ `title`            â€“ meeting title
    â€¢ `started_at`       â€“ UTC timestamp, defaults to now
    â€¢ `expected_chunks`  â€“ total chunks we expect (can be NULL if unknown)
    â€¢ `received_chunks`  â€“ number of chunks we have stored so far
    â€¢ `transcript_text`  â€“ raw concatenated transcript
    â€¢ `summary_markdown` â€“ GPT summary (markdown)
    â€¢ `done`             â€“ True once summary_markdown is filled
    """
    id: uuid.UUID | None = Field(default_factory=uuid.uuid4, primary_key=True)
    title: str
    started_at: dt.datetime = Field(default_factory=dt.datetime.utcnow)
    expected_chunks: int | None = None
    received_chunks: int = 0
    transcript_text: Optional[str] = None
    summary_markdown: Optional[str] = None
    done: bool = False


class MeetingCreate(SQLModel):
    """
    Payload for creating a meeting from the frontend.
    """
    title: str
    expected_chunks: int | None = None


class MeetingRead(SQLModel):
    """
    What we send back to the frontend.
    """
    id: uuid.UUID
    title: str
    started_at: dt.datetime
    summary_markdown: Optional[str]
    transcript_text: Optional[str]   # <â€” added so the frontend can display it
    done: bool


<./frontend\Dockerfile>
# â”€â”€â”€ build â”€â”€â”€â”€â”€â”€â”€â”€
................................

<./frontend\index.html>
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>MeetScribe</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <!-- Inter 400; swap = render immediately with fallback -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400&display=swap"
      rel="stylesheet"
    />
  </head>

  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


<./frontend\nginx.conf>
server {
  listen 80;
  server_name _;
  location /api/ {
    proxy_pass         http://backend:8000;
    proxy_set_header   Host $host;
    proxy_set_header   X-Real-IP $remote_addr;
    proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
  }
  location / {
    root /usr/share/nginx/html;
    try_files $uri /index.html;
  }
}



<./frontend\package-lock.json>
{
  "name": "meetscr
................................

<./frontend\package.json>
{
  "name": "meetscr
................................

<./frontend\tsconfig.json>
{
  "compilerOptions
................................

<./frontend\vite.config.ts>
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [react()],
  build: { outDir: "dist", emptyOutDir: true }
});



<./frontend\src\App.tsx>
import React from "react";
import { Routes, Route, Navigate } from "react-router-dom";
import Record from "./pages/Record";
import Summary from "./pages/Summary";

export default function App() {
  return (
    <Routes>
      <Route path="/" element={<Navigate to="/record" replace />} />
      <Route path="/record" element={<Record />} />
      <Route path="/summary/:mid" element={<Summary />} />
    </Routes>
  );
}



<./frontend\src\main.tsx>
import React from "react";
import ReactDOM from "react-dom/client";
import { BrowserRouter } from "react-router-dom";
import App from "./App";

ReactDOM.createRoot(document.getElementById("root")!).render(
  <BrowserRouter>
    <App />
  </BrowserRouter>
);



<./frontend\src\pages\Record.tsx>
import React, { useRef, useState } from "react";

export default function Record() {
  const [isRecording, setRecording] = useState(false);
  const [chunks, setChunks] = useState<Blob[]>([]);

  const meetingId = useRef<string | null>(null);
  const mediaRef = useRef<MediaRecorder | null>(null);

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  async function createMeeting() {
    const res = await fetch("/api/meetings", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ title: "Untitled" }), // no expected_chunks yet
    });
    if (!res.ok) throw new Error("failed to create meeting");
    const data = await res.json();
    meetingId.current = data.id;
  }

  async function uploadAllChunks() {
    if (!meetingId.current) return;
    for (const [idx, blob] of chunks.entries()) {
      const fd = new FormData();
      fd.append("meeting_id", meetingId.current);
      fd.append("chunk_id", String(idx));
      fd.append("file", blob, `chunk-${idx}.webm`);
      await fetch("/api/chunks", { method: "POST", body: fd });
    }
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ recording control â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  async function start() {
    await createMeeting();

    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const rec = new MediaRecorder(stream, { mimeType: "audio/webm" });
    mediaRef.current = rec;

    rec.ondataavailable = (e) => {
      if (e.data.size) setChunks((prev) => [...prev, e.data]);
    };

    rec.start(30_000); // slice every 30 s
    setRecording(true);
  }

  async function stop() {
    const rec = mediaRef.current;
    if (!rec) return;

    /* Ask MediaRecorder to flush the partial chunk thatâ€™s <30 s long. */
    rec.requestData();

    /* Wait one tick for ondataavailable to fire before we proceed. */
    await new Promise((r) => setTimeout(r, 100));

    rec.stop();
    setRecording(false);

    await uploadAllChunks();
    window.location.href = `/summary/${meetingId.current}`;
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  return (
    <div style={{ padding: 24, maxWidth: 600, margin: "0 auto" }}>
      <h1>MeetScribe Recorder</h1>

      {!isRecording ? (
        <button onClick={start}>Start</button>
      ) : (
        <button onClick={stop}>Stop</button>
      )}

      <p>Recorded chunks: {chunks.length}</p>
    </div>
  );
}


<./frontend\src\pages\Summary.tsx>
import React, { useEffect, useState } from "react";
import { useParams } from "react-router-dom";
import ReactMarkdown from "react-markdown";

export default function Summary() {
  const { mid } = useParams();
  const [summary, setSummary] = useState("â³ Waiting for summaryâ€¦");
  const [transcript, setTranscript] = useState<string | null>(null);

  useEffect(() => {
    // poll until meeting is done
    const iv = setInterval(async () => {
      const res = await fetch(`/api/meetings/${mid}`);
      if (!res.ok) return;
      const data = await res.json();
      if (data.done) {
        setSummary(data.summary_markdown || "No summary");
        setTranscript(data.transcript_text || null);
        clearInterval(iv);
      }
    }, 5_000);
    return () => clearInterval(iv);
  }, [mid]);

  // shared font style for this page
  const fontStyle: React.CSSProperties = {
    fontFamily: '"Inter", sans-serif',
    fontSize: 18,
    fontWeight: 400,
    fontFeatureSettings: '"ss01" "ss02"',
    lineHeight: 1.6,
  };

  return (
    <div style={{ ...fontStyle, maxWidth: 800, margin: "0 auto", padding: 24 }}>
      <h1 style={{ marginTop: 0 }}>Meeting Summary</h1>

      {/* markdown summary */}
      <ReactMarkdown>{summary}</ReactMarkdown>

      {/* raw transcript */}
      {transcript && (
        <>
          <h2 style={{ marginTop: 32 }}>Full Transcript (raw)</h2>
          <pre
            style={{
              ...fontStyle,
              whiteSpace: "pre-wrap",
              background: "#f5f5f5",
              padding: 16,
              borderRadius: 4,
              overflowX: "auto",
            }}
          >
            {transcript}
          </pre>
        </>
      )}
    </div>
  );
}


