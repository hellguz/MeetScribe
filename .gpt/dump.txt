<./.env>
# ===== App =====
SECRET_KEY=change-me
OPENAI_API_KEY=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
# ===== Stripe (dummy) =====
STRIPE_SECRET_KEY=sk_test_dummy
STRIPE_WEBHOOK_SECRET=whsec_dummy
# ===== Whisper =====
WHISPER_MODEL_SIZE=tiny



<./docker-compose.yml>
version: "3.8"
services:
  backend:
    build: ./backend
    ports:
      - "8000:8000"
    volumes:
      - ./data:/app/data         # audio + sqlite
    env_file:
      - .env

  frontend:
    build: ./frontend
    ports:
      - "80:80"
    depends_on:
      - backend



<./backend\Dockerfile>
FROM python:3.12-sli
................................

<./backend\requirements.txt>
fastapi==0.111.0
uvicorn[standard]==0.29.0
sqlmodel==0.0.16
pydantic-settings==2.3.1
python-multipart==0.0.9
faster-whisper==1.1.1
openai==1.23.6



<./backend\app\config.py>
from pathlib import Path
from functools import lru_cache
from pydantic_settings import BaseSettings, SettingsConfigDict

BASE_DIR = Path(__file__).resolve().parent.parent

class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_file=".env", extra="ignore")

    secret_key: str
    openai_api_key: str
    whisper_model_size: str = "tiny"

    db_path: Path = BASE_DIR / "data" / "db.sqlite3"

@lru_cache
def get_settings() -> "Settings":
    return Settings()

settings = get_settings()



<./backend\app\main.py>
import uuid
import shutil
from pathlib import Path
from typing import List

import openai
from fastapi import FastAPI, File, UploadFile, HTTPException, Form
from fastapi.responses import FileResponse
from fastapi.staticfiles import StaticFiles
from sqlmodel import Field, Session, SQLModel, create_engine, select

from .config import settings
from .models import Meeting, MeetingCreate, MeetingRead

# ─── initialise services ──────────────────────────────────────────────────────
openai.api_key = settings.openai_api_key
engine = create_engine(f"sqlite:///{settings.db_path}", echo=False)
SQLModel.metadata.create_all(engine)

# prepare folders
AUDIO_DIR = Path("data/audio")
AUDIO_DIR.mkdir(parents=True, exist_ok=True)

from faster_whisper import WhisperModel
_whisper = WhisperModel(settings.whisper_model_size, device="cpu", compute_type="int8")

# ─── helpers ──────────────────────────────────────────────────────────────────
def transcribe(path: Path) -> str:
    segments, _ = _whisper.transcribe(str(path), beam_size=5)
    return " ".join(s.text for s in segments)

def summarise(text: str) -> str:
    rsp = openai.chat.completions.create(
        model="gpt-4o-mini",
        temperature=0.3,
        messages=[
            {"role": "system", "content": "You summarise meetings into markdown."},
            {"role": "user", "content": f"Summarise:\n{text}"},
        ],
    )
    return rsp.choices[0].message.content.strip()

# ─── FastAPI ──────────────────────────────────────────────────────────────────
app = FastAPI(title="MeetScribe MVP")

# serve frontend SPA (static dist) from / (added at runtime)
# app.mount("/", StaticFiles(directory="/app/static", html=True), name="static")

@app.post("/api/meetings", response_model=MeetingRead, status_code=201)
def create_meeting(body: MeetingCreate):
    with Session(engine) as db:
        mtg = Meeting(**body.dict())
        db.add(mtg)
        db.commit()
        db.refresh(mtg)
        return mtg

@app.post("/api/chunks")
async def upload_chunk(
    meeting_id: uuid.UUID = Form(...),
    chunk_id: str = Form(...),
    file: UploadFile = File(...)
):
    with Session(engine) as db:
        mtg = db.get(Meeting, meeting_id)
        if not mtg:
            raise HTTPException(404, "meeting not found")

        # save file
        mtg_dir = AUDIO_DIR / str(meeting_id)
        mtg_dir.mkdir(parents=True, exist_ok=True)
        chunk_path = mtg_dir / f"{chunk_id}.webm"
        with chunk_path.open("wb") as f:
            shutil.copyfileobj(file.file, f)

        # transcribe
        text = transcribe(chunk_path)
        mtg.transcript_text = (mtg.transcript_text or "") + " " + text
        mtg.received_chunks += 1

        # summarise if done
        if mtg.expected_chunks and mtg.received_chunks >= mtg.expected_chunks:
            mtg.summary_markdown = summarise(mtg.transcript_text)
            mtg.done = True

        db.add(mtg)
        db.commit()
        return {"ok": True}

@app.get("/api/meetings/{mid}", response_model=MeetingRead)
def get_meeting(mid: uuid.UUID):
    with Session(engine) as db:
        mtg = db.get(Meeting, mid)
        if not mtg:
            raise HTTPException(404)
        return mtg

@app.get("/healthz")
def health():
    return {"status": "ok"}



<./backend\app\models.py>
import uuid
import datetime as dt
from typing import Optional

from sqlmodel import SQLModel, Field

class Meeting(SQLModel, table=True):
    id: uuid.UUID | None = Field(default_factory=uuid.uuid4, primary_key=True)
    title: str
    started_at: dt.datetime = Field(default_factory=dt.datetime.utcnow)
    expected_chunks: int | None = None
    received_chunks: int = 0
    transcript_text: Optional[str] = None
    summary_markdown: Optional[str] = None
    done: bool = False

class MeetingCreate(SQLModel):
    title: str
    expected_chunks: int | None = None

class MeetingRead(SQLModel):
    id: uuid.UUID
    title: str
    started_at: dt.datetime
    summary_markdown: Optional[str]
    done: bool



<./frontend\Dockerfile>
# ─── build ────────
................................

<./frontend\index.html>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MeetScribe</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
</head>
<body>
  <div id="root"></div>
  <script type="module" src="/src/main.tsx"></script>
</body>
</html>



<./frontend\nginx.conf>
server {
  listen 80;
  server_name _;
  location /api/ {
    proxy_pass         http://backend:8000;
    proxy_set_header   Host $host;
    proxy_set_header   X-Real-IP $remote_addr;
    proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
  }
  location / {
    root /usr/share/nginx/html;
    try_files $uri /index.html;
  }
}



<./frontend\package-lock.json>
{
  "name": "meetscr
................................

<./frontend\package.json>
{
  "name": "meetscr
................................

<./frontend\tsconfig.json>
{
  "compilerOptions
................................

<./frontend\vite.config.ts>
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [react()],
  build: { outDir: "dist", emptyOutDir: true }
});



<./frontend\src\App.tsx>
import React from "react";
import { Routes, Route, Navigate } from "react-router-dom";
import Record from "./pages/Record";
import Summary from "./pages/Summary";

export default function App() {
  return (
    <Routes>
      <Route path="/" element={<Navigate to="/record" replace />} />
      <Route path="/record" element={<Record />} />
      <Route path="/summary/:mid" element={<Summary />} />
    </Routes>
  );
}



<./frontend\src\main.tsx>
import React from "react";
import ReactDOM from "react-dom/client";
import { BrowserRouter } from "react-router-dom";
import App from "./App";

ReactDOM.createRoot(document.getElementById("root")!).render(
  <BrowserRouter>
    <App />
  </BrowserRouter>
);



<./frontend\src\pages\Record.tsx>
import React, { useRef, useState } from "react";

export default function Record() {
  const [isRecording, setRecording] = useState(false);
  const [chunks, setChunks] = useState<Blob[]>([]);
  const meetingId = useRef<string | null>(null);
  const mediaRef = useRef<MediaRecorder | null>(null);

  async function start() {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const rec = new MediaRecorder(stream, { mimeType: "audio/webm" });
    mediaRef.current = rec;

    rec.ondataavailable = e => {
      if (e.data.size) setChunks(prev => [...prev, e.data]);
    };
    rec.start(30_000);
    setRecording(true);

    // create meeting on backend
    const res = await fetch("/api/meetings", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ title: "Untitled", expected_chunks: null })
    });
    const data = await res.json();
    meetingId.current = data.id;
  }

  async function stop() {
    mediaRef.current?.stop();
    setRecording(false);

    if (!meetingId.current) return;
    // upload chunks sequentially
    for (const [idx, blob] of chunks.entries()) {
      const fd = new FormData();
      fd.append("meeting_id", meetingId.current);
      fd.append("chunk_id", String(idx));
      fd.append("file", blob, `chunk-${idx}.webm`);
      await fetch("/api/chunks", { method: "POST", body: fd });
    }

    window.location.href = `/summary/${meetingId.current}`;
  }

  return (
    <div style={{ padding: 24, maxWidth: 600, margin: "0 auto" }}>
      <h1>MeetScribe Recorder</h1>
      {!isRecording ? (
        <button onClick={start}>Start</button>
      ) : (
        <button onClick={stop}>Stop</button>
      )}
      <p>Recorded chunks: {chunks.length}</p>
    </div>
  );
}



<./frontend\src\pages\Summary.tsx>
import React, { useEffect, useState } from "react";
import { useParams } from "react-router-dom";

export default function Summary() {
  const { mid } = useParams();
  const [md, setMd] = useState("⏳ Waiting for summary…");

  useEffect(() => {
    const iv = setInterval(async () => {
      const res = await fetch(`/api/meetings/${mid}`);
      if (res.ok) {
        const data = await res.json();
        if (data.done) {
          setMd(data.summary_markdown || "No summary");
          clearInterval(iv);
        }
      }
    }, 5000);
    return () => clearInterval(iv);
  }, [mid]);

  return (
    <div style={{ whiteSpace: "pre-wrap", padding: 24 }}>{md}</div>
  );
}


