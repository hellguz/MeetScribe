<./frontend/Dockerfile>
# ─── build stage ───────────────────────────────────────────────────────────────
FROM node:20-alpine AS builder
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci
COPY . .
RUN npm run build

# ─── run stage ────────────────────────────────────────────────────────────────
FROM nginx:1.27-alpine
COPY --from=builder /app/dist /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]


<./frontend/package.json>
{
  "name": "meetscribe-frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@stripe/react-stripe-js": "^2.4.0",
    "@stripe/stripe-js": "^2.4.0",
    "axios": "^1.7.3",
    "idb-keyval": "^6.2.1",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-markdown": "^9.1.8",
    "react-router-dom": "^6.23.1",
    "react-use-websocket": "^4.5.3"
  },
  "devDependencies": {
    "@types/react": "^18.2.40",
    "@types/react-dom": "^18.2.17",
    "@vitejs/plugin-react": "^4.3.1",
    "typescript": "^5.5.0",
    "vite": "^5.2.0"
  }
}


<./frontend/tsconfig.json>
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "jsx": "react-jsx",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "types": ["vite/client"]
  },
  "include": ["src"]
}


<./frontend/vite.config.ts>
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [react()],
  server: { proxy: { "/api": "http://localhost:8000" } }
});


<./frontend/public/index.html>
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>MeetScribe</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


<./frontend/src/main.tsx>
import React from "react";
import ReactDOM from "react-dom/client";
import { BrowserRouter } from "react-router-dom";
import App from "./App";

ReactDOM.createRoot(document.getElementById("root")!).render(
  <BrowserRouter>
    <App />
  </BrowserRouter>
);


<./frontend/src/App.tsx>
import React from "react";
import { Route, Routes, Navigate } from "react-router-dom";
import Record from "./pages/Record";
import Summary from "./pages/Summary";
import Checkout from "./pages/Checkout";

export default function App() {
  return (
    <Routes>
      <Route path="/" element={<Navigate to="/record" replace />} />
      <Route path="/record" element={<Record />} />
      <Route path="/summary/:mid" element={<Summary />} />
      <Route path="/checkout" element={<Checkout />} />
    </Routes>
  );
}


<./frontend/src/api/client.ts>
import axios from "axios";

const api = axios.create({
  baseURL: "/api",
  withCredentials: true
});

export function setAuth(token: string | null) {
  if (token) api.defaults.headers.common.Authorization = `Bearer ${token}`;
  else delete api.defaults.headers.common.Authorization;
}

export default api;


<./frontend/src/hooks/useRecorder.ts>
import { useCallback, useEffect, useRef, useState } from "react";
import { set, get } from "idb-keyval";

export interface ChunkMeta {
  id: string;
  blob: Blob;
}

export default function useRecorder(chunkMs = 30_000) {
  const [isRecording, setIsRecording] = useState(false);
  const [chunks, setChunks] = useState<ChunkMeta[]>([]);
  const mediaRef = useRef<MediaRecorder | null>(null);

  const start = useCallback(async () => {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const rec = new MediaRecorder(stream, { mimeType: "audio/webm" });
    mediaRef.current = rec;

    rec.ondataavailable = async e => {
      if (e.data.size === 0) return;
      const id = crypto.randomUUID();
      const meta: ChunkMeta = { id, blob: e.data };
      setChunks(prev => [...prev, meta]);
      await set(id, e.data); // persist
    };

    rec.start(chunkMs);
    setIsRecording(true);
  }, [chunkMs]);

  const stop = useCallback(() => {
    mediaRef.current?.stop();
    mediaRef.current = null;
    setIsRecording(false);
  }, []);

  const clearPersisted = useCallback(async () => {
    for (const c of chunks) await set(c.id, undefined);
    setChunks([]);
  }, [chunks]);

  useEffect(() => {
    // restore chunks from previous session
    (async () => {
      const keys = await get<any>("__keys__").catch(() => []);
      if (keys?.length) {
        const restored: ChunkMeta[] = [];
        for (const k of keys) {
          const blob = await get<Blob>(k);
          if (blob) restored.push({ id: k, blob });
        }
        setChunks(restored);
      }
    })();
  }, []);

  return { isRecording, chunks, start, stop, clearPersisted };
}


<./frontend/src/hooks/useUploader.ts>
import { useEffect, useState } from "react";
import useWebSocket from "react-use-websocket";
import api from "../api/client";
import { ChunkMeta } from "./useRecorder";

export function useUploader(meetingId: string, chunks: ChunkMeta[]) {
  const [sentIds, setSentIds] = useState<Set<string>>(new Set());
  const { sendJsonMessage, lastJsonMessage, readyState } = useWebSocket(
    `/api/ws?meeting_id=${meetingId}`,
    { share: true, shouldReconnect: () => true }
  );

  // fallback REST upload when WS not ready
  useEffect(() => {
    (async () => {
      if (readyState !== 1) return;
      for (const c of chunks) {
        if (sentIds.has(c.id)) continue;
        sendJsonMessage({ id: c.id, size: c.blob.size });
        await api.postForm(
          "/chunks",
          { meeting_id: meetingId, chunk_id: c.id, file: c.blob },
          { headers: { "Content-Type": "multipart/form-data" } }
        );
        setSentIds(prev => new Set(prev).add(c.id));
      }
    })();
  }, [chunks, readyState, sentIds, meetingId, sendJsonMessage]);

  useEffect(() => {
    if (lastJsonMessage?.acked) {
      setSentIds(prev => new Set([...prev, ...lastJsonMessage.acked]));
    }
  }, [lastJsonMessage]);

  return { sent: sentIds.size, total: chunks.length };
}


<./frontend/src/pages/Record.tsx>
import React, { useState } from "react";
import useRecorder from "../hooks/useRecorder";
import { useNavigate } from "react-router-dom";
import api from "../api/client";
import RecorderButton from "../components/RecorderButton";
import UploadProgress from "../components/UploadProgress";

export default function Record() {
  const [meetingId, setMeetingId] = useState<string | null>(null);
  const rec = useRecorder();
  const navigate = useNavigate();

  const handleStart = async () => {
    const { data } = await api.post("/meetings", { title: "Untitled" });
    setMeetingId(data.id);
    rec.start();
  };

  const handleStop = () => {
    rec.stop();
    if (meetingId) navigate(`/summary/${meetingId}`);
  };

  return (
    <div className="p-6 space-y-6 max-w-xl mx-auto">
      <h1 className="text-3xl font-bold">MeetScribe Recorder</h1>
      {!rec.isRecording ? (
        <RecorderButton label="Start" onClick={handleStart} />
      ) : (
        <RecorderButton label="Stop" onClick={handleStop} danger />
      )}
      {meetingId && (
        <UploadProgress meetingId={meetingId} chunks={rec.chunks} />
      )}
      <button
        className="border px-3 py-1 rounded"
        onClick={() => rec.clearPersisted()}
        disabled={rec.isRecording}
      >
        Clear saved chunks
      </button>
    </div>
  );
}


<./frontend/src/pages/Summary.tsx>
import React, { useEffect, useState } from "react";
import { useParams } from "react-router-dom";
import ReactMarkdown from "react-markdown";
import api from "../api/client";

export default function Summary() {
  const { mid } = useParams();
  const [md, setMd] = useState<string>("Loading…");

  useEffect(() => {
    (async () => {
      const { data } = await api.get(`/meetings/${mid}`);
      setMd(data.summary_markdown || "⏳ Summarising… refresh in a bit.");
    })();
  }, [mid]);

  return (
    <div className="prose mx-auto p-6">
      <ReactMarkdown>{md}</ReactMarkdown>
    </div>
  );
}


<./frontend/src/pages/Checkout.tsx>
import React from "react";
import { loadStripe } from "@stripe/stripe-js";
import { Elements } from "@stripe/react-stripe-js";
import api from "../api/client";

const stripePromise = loadStripe(import.meta.env.VITE_STRIPE_PUBKEY!);

export default function Checkout() {
  const handleClick = async () => {
    const { data } = await api.post("/billing/checkout");
    window.location.href = data.url;
  };

  return (
    <div className="p-6 text-center space-y-4">
      <h1 className="text-3xl font-bold">Subscribe</h1>
      <p>Unlimited transcriptions • €3 / month</p>
      <Elements stripe={stripePromise}>
        <button
          className="bg-black text-white px-4 py-2 rounded"
          onClick={handleClick}
        >
          Continue to Stripe
        </button>
      </Elements>
    </div>
  );
}


<./frontend/src/components/RecorderButton.tsx>
import React from "react";

export default function RecorderButton({
  label,
  onClick,
  danger = false
}: {
  label: string;
  onClick: () => void;
  danger?: boolean;
}) {
  return (
    <button
      onClick={onClick}
      className={`px-6 py-3 rounded text-white ${
        danger ? "bg-red-600" : "bg-green-600"
      }`}
    >
      {label}
    </button>
  );
}


<./frontend/src/components/UploadProgress.tsx>
import React from "react";
import { useUploader } from "../hooks/useUploader";
import { ChunkMeta } from "../hooks/useRecorder";

export default function UploadProgress({
  meetingId,
  chunks
}: {
  meetingId: string;
  chunks: ChunkMeta[];
}) {
  const { sent, total } = useUploader(meetingId, chunks);
  return (
    <div>
      Uploaded {sent}/{total} chunks
    </div>
  );
}


<./frontend/src/components/PaywallGuard.tsx>
import React, { PropsWithChildren, useEffect, useState } from "react";
import { useNavigate } from "react-router-dom";
import api from "../api/client";

export default function PaywallGuard({ children }: PropsWithChildren) {
  const [allowed, setAllowed] = useState<boolean | null>(null);
  const navigate = useNavigate();

  useEffect(() => {
    (async () => {
      try {
        const { data } = await api.get("/me");
        setAllowed(data.subscription_active);
        if (!data.subscription_active) navigate("/checkout");
      } catch {
        navigate("/checkout");
      }
    })();
  }, [navigate]);

  if (allowed === null) return null;
  return <>{children}</>;
}


<./frontend/src/components/TemplateBadge.tsx>
import React from "react";

export default function TemplateBadge({ type }: { type: string }) {
  return (
    <span className="border rounded px-2 py-0.5 text-xs bg-gray-100">
      {type}
    </span>
  );
}
